#include "CuttingStockHeuristicIntegerSolver.hpp"

#include <list>
#include <iostream>
using namespace std;

#include "Time.hpp"
#include "GlpkUtil.hpp"


CuttingStockSolution<int>* CuttingStockHeuristicIntegerSolver::solve(
        CuttingStockInstance* instance)
{
    Timer totalExecutionTimer;
    Timer heuristicTimer;

    totalExecutionTimer.start();

    // Solves the linear relaxation
    CuttingStockSolution<double>* linearRelaxationSolution =
        linearRelaxationSolver.solve(instance);

    // Solves the heuristic
    heuristicTimer.start();
    CuttingStockSolution<int>* heuristicSolution =
        solveHeuristic(instance, linearRelaxationSolution);
    heuristicTimer.stop();

    totalExecutionTimer.stop();

    runtimeStatistics.setTotalExecutionTime(totalExecutionTimer.getMicroseconds());
    runtimeStatistics.setHeuristicExecutionTime(heuristicTimer.getMicroseconds());

    delete linearRelaxationSolution;

    return heuristicSolution;
}


CuttingStockSolution<int>* CuttingStockHeuristicIntegerSolver::solve(
        CuttingStockInstance* instance,
        CuttingStockSolution<double>* linearRelaxationSolution)
{
    assert(instance != 0);
    assert(linearRelaxationSolution != 0);

    Timer executionTimer;

    executionTimer.start();
    CuttingStockSolution<int>* solution =
            solveHeuristic(instance, linearRelaxationSolution);
    executionTimer.stop();

    runtimeStatistics.setTotalExecutionTime(executionTimer.getMicroseconds());
    runtimeStatistics.setHeuristicExecutionTime(executionTimer.getMicroseconds());

    return solution;
}


CuttingStockSolution<int>* CuttingStockHeuristicIntegerSolver::solveHeuristic(
        CuttingStockInstance* instance,
        CuttingStockSolution<double>* linearRelaxationSolution)
{
    glpkInit();

    // m is the number of cutting requirements (width instances).
    const int m = instance->getRequirementCount();
    assert(m > 0);

    // Gets the list of patterns from the linear relaxation solution
    list<CuttingStockPattern*> patterns;
    for (int j = 1; j <= linearRelaxationSolution->getPatternCount(); j++) {
        if (investigateAllPatterns || linearRelaxationSolution->getAllocation(j) > 0) {
            CuttingStockPattern* pattern = linearRelaxationSolution->getPattern(j);
            patterns.push_back(pattern);
        }
    }

    // n is the number of allocated cutting patterns generated by the linear relaxation solution.
    const int n = patterns.size();
    assert(n > 0);


    // Creates the GLPK problem instance.
    glp_prob* lp = glp_create_prob();
    glp_set_prob_name(lp, "cutting-stock heuristic");

    // The objective function will be minimized.
    glp_set_obj_dir(lp, GLP_MIN);

    // Adds the constraints (rows)
    glp_add_rows(lp, m);
    for (int i = 1; i <= m; i++) {
        glp_set_row_bnds(lp, i, GLP_LO, instance->getPieces(instance->getWidth(i)), 0);
    }

    // Adds the variables (columns) and also set the coefficients of the objective function.
    glp_add_cols(lp, n);
    for (int j = 1; j <= n; j++) {
        glp_set_col_kind(lp, j, GLP_IV);        // x[j] is integer
        glp_set_col_bnds(lp, j, GLP_LO, 0, 0);  // x[j] >= 0
        glp_set_obj_coef(lp, j, 1);             // c[j] = 1
    }

    // Builds the A matrix, the matrix of cutting patterns generated by the
    // linear relaxation solution.
    const int A_size = 1 + (m * n);
    int A_line[A_size], A_column[A_size];
    double A_value[A_size];

    int k = 1;
    int j = 1;
    for (list<CuttingStockPattern*>::iterator it = patterns.begin(); it != patterns.end(); it++)
    {
        CuttingStockPattern* pattern = (*it);    // column A_j
        for (int i = 1; i <= m; i++)
        {
            A_line[k] = i;                       // line i
            A_column[k] = j;                     // column j
            A_value[k] = pattern->getPieces(i);  // a[i,j] = (A_j)[i]
            k++;
        }
        j++;
    }


    // Loads the A matrix.
    glp_load_matrix(lp, (k-1), A_line, A_column, A_value);


    // GLPK MIP solver control parameters
    glp_iocp* mipParameters = new glp_iocp();
    glp_init_iocp(mipParameters);
    // Defines the branch-and-bound/cut backtracking mode
    mipParameters->bt_tech = (int)backtrackingMode;
    // Uses the internal GLPK MIP pre-solver
    //mipParameters->presolve = GLP_ON;

    int simplexStatusCode = glp_simplex(lp, NULL);
    assert(simplexStatusCode == 0);

    // Invokes the GLPK MIP solver
    int integerOptimizerStatusCode = glp_intopt(lp, mipParameters);;
    int mipStatusCode = glp_mip_status(lp);

    // Verifies if the solution is feasible
    bool isFeasible;
    if (integerOptimizerStatusCode == 0 && mipStatusCode == GLP_OPT)
        isFeasible = true;
    else {
        isFeasible = false;
        //cerr << glpkIntegerOptimizerStatusName(integerOptimizerStatusCode) << endl;
        //cerr << glpkMipStatusName(mipStatusCode) << endl;
    }

    // Instantiates the solution object.
    CuttingStockSolution<int>* solution;
    if (isFeasible)
    {
        solution = new CuttingStockSolution<int>();

        // Adds the patterns and sets their allocations
        int j = 1;
        for (list<CuttingStockPattern*>::iterator it = patterns.begin(); it != patterns.end(); it++)
        {
            CuttingStockPattern* pattern = (*it);
            solution->addPattern(pattern->clone()); // Adds a clone (deep copy) of the pattern.

            double x = glp_mip_col_val(lp, j);
            solution->setAllocation(j, (int)x);
            assert(solution->getAllocation(j) == x);

            j++;
        }

        // Sets the summation of pattern allocations (objective function value)
        double v = glp_mip_obj_val(lp);
        solution->setTotalAllocation(v);
        assert(solution->getTotalAllocation() == v);
    }
    else {
        solution = 0; // NULL
    }

    return solution;
}
