#include "CuttingStockLinearRelaxationSolver.hpp"

#include <assert.h>
#include <iostream>
#include <list>
using namespace std;


#include "IntegerKnapsackSolver.hpp"
#include "Time.hpp"
#include "GlpkUtil.hpp"


CuttingStockSolution<double>*
    CuttingStockLinearRelaxationSolver::solve(CuttingStockInstance* instance)
{
    assert(instance != 0);

    glpkInit();

    // Measures execution time.
    Timer executionTimer;
    executionTimer.start();

    //
    // INITIALIZATION
    //

    // m is the number of requirements.
    const int m = instance->getRequirementCount();
    assert(m > 0);

    // W is the fixed width of all bars/rolls to be cut.
    const int W = instance->getBarWidth();
    assert(W > 0);

    // Instantiates the solution object.
    CuttingStockSolution<double>* solution =
        new CuttingStockSolution<double>();

    // Creates the GLPK problem instance.
    glp_prob* lp = glp_create_prob();
    glp_set_prob_name(lp, "cutting-stock linear relaxation");

    // The objective function will be minimized.
    glp_set_obj_dir(lp, GLP_MIN);


    // Adds the constraints (rows)
    glp_add_rows(lp, m);
    for (int i = 1; i <= m; i++) {
        glp_set_row_bnds(lp, i, GLP_FX, instance->getPieces(instance->getWidth(i)), 0);
    }

    // Adds the variables (columns) and also set the coefficients of the objective function.
    glp_add_cols(lp, m);
    for (int i = 1; i <= m; i++) {
        glp_set_col_bnds(lp, i, GLP_LO, 0, 0); // x[i] >= 0
        glp_set_obj_coef(lp, i, 1.0);          // c[i] = 1.0
    }

    //
    // A = a[i,j] is the matrix of cutting patterns. Each column A_j represents a cutting pattern,
    // where a[i,j] is the number of pieces of width w[i] produced by cutting pattern j. In
    // theory j = (1 .. n), where n is the number of all possible cutting patterns. Since n might be
    // a very large number, we will only keep the m cutting patterns that belong to the base of the
    // simplified Simplex method. We will then use an iterative method to add columns to the base.
    //
    // The A matrix is represented in linear form using arrays, a format required
    // by GLPK. We will use arrays of line indexes l, column indexes c and values v, where for each
    // k = (1 .. m x m), a[i,j] = a[l[k],c[k]] = v[k].
    // Please notice that GLPK indexes all arrays by 1, and not by 0.
    //
    const int size = 1 + (m * m);
    int A_line[size], A_column[size];
    double A_value[size];

    // The A matrix will start with a feasible set of m columns that will form an identity matrix.
    // This means that for j = 1 .. m, the cutting pattern j will produce only one bar of width w[j],
    // i.e., a[j,j] = 1 (the remainder widths will produce 0 bars).
    int index = 1;
    for (int j = 1; j <= m; j++) {
        // Adds this intial column to A
        A_column[index] = j;   // column j
        A_line[index] = j;     // line j
        A_value[index] = 1.0;  // a[j,j] = 1
        index++;

        // Adds this initial cutting pattern to the solution
        CuttingStockPattern* pattern = new CuttingStockPattern();
        pattern->addCut(instance->getWidth(j), 1);
        solution->addPattern(pattern);
    }

    // n is the number of columns that are present in the A matrix.
    int n = m;

    // Loads the A matrix.
    glp_load_matrix(lp, m, A_line, A_column, A_value);

    // Used for statistics
    long totalSubproblemExecutionTime = 0;
    int iterations = 0;

    //
    // PROBLEM SOLVING ITERATIONS
    //

    bool stop = false;
    do
    {
        // Solve the current iteration's linear program using SIMPLEX.
        int statusCode = glp_simplex(lp, NULL);
        // The SIMPLEX return code should be 0; means no errors.
        assert(statusCode == 0);

        // Gets the dual variables
        double dualVariable[1+m];
        for (int i = 1; i <= m; i++)
            dualVariable[i] = glp_get_row_dual(lp, i);


        //
        // SOLVES THE SUBPROBLEM (INTEGER KNAPSACK)
        //

        // Measures subproblem execution time
        Timer subproblemExecutionTimer;
        subproblemExecutionTimer.start();

        // The cutting pattern column A_j is generated by solving the integer knapsack problem.
        IntegerKnapsackInstance<double>* knapsackInstance = new IntegerKnapsackInstance<double>();
        knapsackInstance->setCapacity(W);
        for (int i = 1; i <= m; i++)
            knapsackInstance->addItem(i, dualVariable[i], instance->getWidth(i));

        IntegerKnapsackSolution<double>* knapsackSolution = knapsackSolver.solve(knapsackInstance);

        // Measures subproblem execution time
        subproblemExecutionTimer.stop();
        totalSubproblemExecutionTime += subproblemExecutionTimer.getMicroseconds();



        // If the solution value to the knapsack problem is less than equal to 1, all reduced costs
        // are greater than or equal to zero, and thus there's no way to optimize the system further.
        if (floatingPointComparer.compare(knapsackSolution->getOptimalValue(), 1.0) <= 0)
        {
            // STOP
            stop = true;
        }
        else
        {
            //
            // Adds a new pattern/column A_j (solution to the knapsack subproblem) to the instance
            // of the problem, and recalculate the SIMPLEX in the next iteration.
            //

            CuttingStockPattern* pattern = new CuttingStockPattern();
            int columnIndex[1+m];
            double columnValue[1+m];

            for (int i = 1; i <= m; i++) {
                int cutPieces = knapsackSolution->getItemAmount(i);
                pattern->addCut(instance->getWidth(i), cutPieces);

                columnIndex[i] = i;
                columnValue[i] = cutPieces;
            }

            solution->addPattern(pattern);

            glp_add_cols(lp, 1);
            int j = glp_get_num_cols(lp);
            glp_set_col_bnds(lp, j, GLP_LO, 0, 0);
            glp_set_obj_coef(lp, j, 1.0);

            glp_set_mat_col(lp, j, m, columnIndex, columnValue);

            n = n + 1;
        }

        iterations++;
        assert(n == glp_get_num_cols(lp));

        // Clean-up
        delete knapsackInstance;
        delete knapsackSolution;

    }
    while (not stop);

    // Statistics
    executionTimer.stop();
    runtimeStatistics.setTotalExecutionTime(executionTimer.getMicroseconds());
    runtimeStatistics.setSubproblemAverageExecutionTime(totalSubproblemExecutionTime / iterations);


    //
    // Builds the solution
    //

    solution->setTotalAllocation(glp_get_obj_val(lp));

    // Gets the primal variables x
    for (int i = 1; i <= n; i++) {
        double x = glp_get_col_prim(lp, i);

        // Truncates x if it exceeds the floating point precision used by this solver.
        if (x < floatingPointComparer.getPrecision())
            x = 0;

        solution->setAllocation(i, x);
    }


    // Clean-up
    glp_delete_prob(lp);

    return solution;
}
